<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>bank_regulation_project.utils API documentation</title>
<meta name="description" content="This module provides several functions useful to run the simulations that we define in the economy.py file …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bank_regulation_project.utils</code></h1>
</header>
<section id="section-intro">
<p>This module provides several functions useful to run the simulations that we define in the economy.py file.</p>
<p>It notably includes the generate_GBM function, which is used to simulate sample paths of a geometric Brownian motion.</p>
<p>The latter was inspired by the code snippet provided on the Wikipedia page about geometric Brownian motions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides several functions useful to run the simulations that we define in the economy.py file.

It notably includes the generate_GBM function, which is used to simulate sample paths of a geometric Brownian motion.

The latter was inspired by the code snippet provided on the Wikipedia page about geometric Brownian motions.
&#34;&#34;&#34;

# ----------------------------------------------------------------------------------------------------------------------
# IMPORT(S)

import numpy as np


# ----------------------------------------------------------------------------------------------------------------------
# CONTENT

def generate_GBM(mu, sigma, n=50, dt=0.1, x_0=10, random_seed=None):
    &#34;&#34;&#34;
    This function is used to simulate a geometric Brownian motion. It was inspired by the code snippet provided on the
    Wikipedia page about geometric Brownian motions (see section &#39;Simulating sample paths&#39;).

    It requires several arguments:

    - mu: the instantaneous drift of the geometric Brownian motion;

    - sigma: its instantaneous variance;

    - n: the number of timesteps to simulate beside the starting point x_0 (see below);

    - dt: as in the formulas for the geometric Brownian motion, this argument can be interpreted as the length of each
    timestep at which we simulate the motion. This, combined with the number of periods, is necessary for a programmatic
    approximation of continuous time implied by the Brownian motion;

    - x_0: the initial value from which the simulation starts;

    - random_seed: this argument may contain any natural integer which will determine the &#34;state of the world&#34; in which
    the simulation is assumed to occur. As a consequence, calling the generate_GBM function several times with the same
    random_seed will yield the same sample paths each time.

    Therefore, the function returns an array that contains (n+1) points, including the initial value x_0, and constitu-
    tes the simulated path for the geometric Brownian motion.
    &#34;&#34;&#34;

    # We distinguish two cases based on whether a random_seed was passed as an argument or not
    if not random_seed:
        # If no random_seed was set, we run n simulations of a centered normal distribution of variance dt
        normal_component = np.random.normal(0, np.sqrt(dt), size=n)

    else:
        # If a random_seed was passed, we first use it to fix the random state
        np.random.seed(random_seed)
        # Then, we run n simulations of a centered normal distribution of variance dt
        normal_component = np.random.normal(0, np.sqrt(dt), size=n)

    # We multiply each simulation of the centered normal distribution by sigma, we add to it (mu - sigma ** 2 / 2) * dt
    # (this transformation comes from Itô&#39;s lemma) and we eventually apply the exponential to the resulting quantity
    x = np.exp((mu - sigma ** 2 / 2) * dt + sigma * normal_component)

    # We add a 1 at the beginning of the array that contains the x&#39;s (which will correspond to the initial value)
    x = np.concatenate([np.ones(1), x])

    # We multiply each element in the array by the initial value, x_0
    x = x_0 * x.cumprod()

    return x


def NPV_check(row, threshold, under_macro_shock=False, column_indices=None):
    &#34;&#34;&#34;
    This function is a very brief one used in the apply method of the simulation DataFrame in the run_simulation method
    of an Economy instance (cf. the economy.py file).

    It takes two arguments:

    - row: the row of the simulation DataFrame considered for the check (the apply method, set with the axis=1 argument,
    automatically iterates over the rows of the DataFrame);

    - threshold: the positive expected net present value threshold under which a bank using the good asset monitoring
    technology is not expected to be able to compensate for the monitoring cost in the long run.

    The function returns a boolean:

    - True, if the bank has chosen the bad asset monitoring technology at some point in time or if it uses the good te-
    chnology but its cash flows have gone below the positive surplus threshold;

    - False, if none of the two conditions is met.
    &#34;&#34;&#34;
    if not under_macro_shock:
        if row[&#39;has_shirked&#39;]:
            return True
        else:
            return (row.iloc[:-1] &lt;= threshold).sum() &gt; 0

    if under_macro_shock:
        if row[&#39;has_shirked_post_shock&#39;]:
            return True
        else:
            return (row.loc[column_indices] &lt;= threshold).sum() &gt; 0


def get_a_exponent(mu, sigma, r):
    &#34;&#34;&#34;
    This function allows to compute the a_G or a_B exponent defined in the paper, at page 139 for the first time.

    It requires as arguments:

    - mu: the instantaneous drift of the geometric Brownian motion considered;

    - sigma: the instantaneous variance of the geometric Brownian motion considered;

    - r: the interest rate assumed for the economy.

    It then computes and returns the scalar used for instance in the computation of regulator&#39;s liquidation thresholds.
    &#34;&#34;&#34;
    return (1 / 2) + (mu / (sigma ** 2)) + np.sqrt(((mu / (sigma ** 2)) - (1 / 2)) ** 2 + (2 * r) / (sigma ** 2))


def determine_line_color(row):
    &#34;&#34;&#34;
    This function, used in the plot_simulation method of the Economy class (more precisely when plot_shock=True is
    passed), allows to determine what color to use to plot the sequence of cash flows of a given bank.

    This choice is based on whether the bank has shirked at some point in time, before or after the macroeconomic shock.
    &#34;&#34;&#34;

    # In this first case, the bank has shirked before the macroeconomic shock and the line will be dark red
    if row[&#39;has_shirked&#39;]:
        return &#39;darkred&#39;

    # In this second case, the bank has shirked after the macroeconomic shock and the line is orange
    elif row[&#39;has_shirked_post_shock&#39;]:
        return &#39;orange&#39;

    # In this third and final case, the bank has shirked neither before nor after the shock and the line is dark blue
    else:
        return &#39;darkblue&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bank_regulation_project.utils.NPV_check"><code class="name flex">
<span>def <span class="ident">NPV_check</span></span>(<span>row, threshold, under_macro_shock=False, column_indices=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is a very brief one used in the apply method of the simulation DataFrame in the run_simulation method
of an Economy instance (cf. the economy.py file).</p>
<p>It takes two arguments:</p>
<ul>
<li>
<p>row: the row of the simulation DataFrame considered for the check (the apply method, set with the axis=1 argument,
automatically iterates over the rows of the DataFrame);</p>
</li>
<li>
<p>threshold: the positive expected net present value threshold under which a bank using the good asset monitoring
technology is not expected to be able to compensate for the monitoring cost in the long run.</p>
</li>
</ul>
<p>The function returns a boolean:</p>
<ul>
<li>
<p>True, if the bank has chosen the bad asset monitoring technology at some point in time or if it uses the good te-
chnology but its cash flows have gone below the positive surplus threshold;</p>
</li>
<li>
<p>False, if none of the two conditions is met.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def NPV_check(row, threshold, under_macro_shock=False, column_indices=None):
    &#34;&#34;&#34;
    This function is a very brief one used in the apply method of the simulation DataFrame in the run_simulation method
    of an Economy instance (cf. the economy.py file).

    It takes two arguments:

    - row: the row of the simulation DataFrame considered for the check (the apply method, set with the axis=1 argument,
    automatically iterates over the rows of the DataFrame);

    - threshold: the positive expected net present value threshold under which a bank using the good asset monitoring
    technology is not expected to be able to compensate for the monitoring cost in the long run.

    The function returns a boolean:

    - True, if the bank has chosen the bad asset monitoring technology at some point in time or if it uses the good te-
    chnology but its cash flows have gone below the positive surplus threshold;

    - False, if none of the two conditions is met.
    &#34;&#34;&#34;
    if not under_macro_shock:
        if row[&#39;has_shirked&#39;]:
            return True
        else:
            return (row.iloc[:-1] &lt;= threshold).sum() &gt; 0

    if under_macro_shock:
        if row[&#39;has_shirked_post_shock&#39;]:
            return True
        else:
            return (row.loc[column_indices] &lt;= threshold).sum() &gt; 0</code></pre>
</details>
</dd>
<dt id="bank_regulation_project.utils.determine_line_color"><code class="name flex">
<span>def <span class="ident">determine_line_color</span></span>(<span>row)</span>
</code></dt>
<dd>
<div class="desc"><p>This function, used in the plot_simulation method of the Economy class (more precisely when plot_shock=True is
passed), allows to determine what color to use to plot the sequence of cash flows of a given bank.</p>
<p>This choice is based on whether the bank has shirked at some point in time, before or after the macroeconomic shock.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def determine_line_color(row):
    &#34;&#34;&#34;
    This function, used in the plot_simulation method of the Economy class (more precisely when plot_shock=True is
    passed), allows to determine what color to use to plot the sequence of cash flows of a given bank.

    This choice is based on whether the bank has shirked at some point in time, before or after the macroeconomic shock.
    &#34;&#34;&#34;

    # In this first case, the bank has shirked before the macroeconomic shock and the line will be dark red
    if row[&#39;has_shirked&#39;]:
        return &#39;darkred&#39;

    # In this second case, the bank has shirked after the macroeconomic shock and the line is orange
    elif row[&#39;has_shirked_post_shock&#39;]:
        return &#39;orange&#39;

    # In this third and final case, the bank has shirked neither before nor after the shock and the line is dark blue
    else:
        return &#39;darkblue&#39;</code></pre>
</details>
</dd>
<dt id="bank_regulation_project.utils.generate_GBM"><code class="name flex">
<span>def <span class="ident">generate_GBM</span></span>(<span>mu, sigma, n=50, dt=0.1, x_0=10, random_seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This function is used to simulate a geometric Brownian motion. It was inspired by the code snippet provided on the
Wikipedia page about geometric Brownian motions (see section 'Simulating sample paths').</p>
<p>It requires several arguments:</p>
<ul>
<li>
<p>mu: the instantaneous drift of the geometric Brownian motion;</p>
</li>
<li>
<p>sigma: its instantaneous variance;</p>
</li>
<li>
<p>n: the number of timesteps to simulate beside the starting point x_0 (see below);</p>
</li>
<li>
<p>dt: as in the formulas for the geometric Brownian motion, this argument can be interpreted as the length of each
timestep at which we simulate the motion. This, combined with the number of periods, is necessary for a programmatic
approximation of continuous time implied by the Brownian motion;</p>
</li>
<li>
<p>x_0: the initial value from which the simulation starts;</p>
</li>
<li>
<p>random_seed: this argument may contain any natural integer which will determine the "state of the world" in which
the simulation is assumed to occur. As a consequence, calling the generate_GBM function several times with the same
random_seed will yield the same sample paths each time.</p>
</li>
</ul>
<p>Therefore, the function returns an array that contains (n+1) points, including the initial value x_0, and constitu-
tes the simulated path for the geometric Brownian motion.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_GBM(mu, sigma, n=50, dt=0.1, x_0=10, random_seed=None):
    &#34;&#34;&#34;
    This function is used to simulate a geometric Brownian motion. It was inspired by the code snippet provided on the
    Wikipedia page about geometric Brownian motions (see section &#39;Simulating sample paths&#39;).

    It requires several arguments:

    - mu: the instantaneous drift of the geometric Brownian motion;

    - sigma: its instantaneous variance;

    - n: the number of timesteps to simulate beside the starting point x_0 (see below);

    - dt: as in the formulas for the geometric Brownian motion, this argument can be interpreted as the length of each
    timestep at which we simulate the motion. This, combined with the number of periods, is necessary for a programmatic
    approximation of continuous time implied by the Brownian motion;

    - x_0: the initial value from which the simulation starts;

    - random_seed: this argument may contain any natural integer which will determine the &#34;state of the world&#34; in which
    the simulation is assumed to occur. As a consequence, calling the generate_GBM function several times with the same
    random_seed will yield the same sample paths each time.

    Therefore, the function returns an array that contains (n+1) points, including the initial value x_0, and constitu-
    tes the simulated path for the geometric Brownian motion.
    &#34;&#34;&#34;

    # We distinguish two cases based on whether a random_seed was passed as an argument or not
    if not random_seed:
        # If no random_seed was set, we run n simulations of a centered normal distribution of variance dt
        normal_component = np.random.normal(0, np.sqrt(dt), size=n)

    else:
        # If a random_seed was passed, we first use it to fix the random state
        np.random.seed(random_seed)
        # Then, we run n simulations of a centered normal distribution of variance dt
        normal_component = np.random.normal(0, np.sqrt(dt), size=n)

    # We multiply each simulation of the centered normal distribution by sigma, we add to it (mu - sigma ** 2 / 2) * dt
    # (this transformation comes from Itô&#39;s lemma) and we eventually apply the exponential to the resulting quantity
    x = np.exp((mu - sigma ** 2 / 2) * dt + sigma * normal_component)

    # We add a 1 at the beginning of the array that contains the x&#39;s (which will correspond to the initial value)
    x = np.concatenate([np.ones(1), x])

    # We multiply each element in the array by the initial value, x_0
    x = x_0 * x.cumprod()

    return x</code></pre>
</details>
</dd>
<dt id="bank_regulation_project.utils.get_a_exponent"><code class="name flex">
<span>def <span class="ident">get_a_exponent</span></span>(<span>mu, sigma, r)</span>
</code></dt>
<dd>
<div class="desc"><p>This function allows to compute the a_G or a_B exponent defined in the paper, at page 139 for the first time.</p>
<p>It requires as arguments:</p>
<ul>
<li>
<p>mu: the instantaneous drift of the geometric Brownian motion considered;</p>
</li>
<li>
<p>sigma: the instantaneous variance of the geometric Brownian motion considered;</p>
</li>
<li>
<p>r: the interest rate assumed for the economy.</p>
</li>
</ul>
<p>It then computes and returns the scalar used for instance in the computation of regulator's liquidation thresholds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_a_exponent(mu, sigma, r):
    &#34;&#34;&#34;
    This function allows to compute the a_G or a_B exponent defined in the paper, at page 139 for the first time.

    It requires as arguments:

    - mu: the instantaneous drift of the geometric Brownian motion considered;

    - sigma: the instantaneous variance of the geometric Brownian motion considered;

    - r: the interest rate assumed for the economy.

    It then computes and returns the scalar used for instance in the computation of regulator&#39;s liquidation thresholds.
    &#34;&#34;&#34;
    return (1 / 2) + (mu / (sigma ** 2)) + np.sqrt(((mu / (sigma ** 2)) - (1 / 2)) ** 2 + (2 * r) / (sigma ** 2))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="bank_regulation_project" href="index.html">bank_regulation_project</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bank_regulation_project.utils.NPV_check" href="#bank_regulation_project.utils.NPV_check">NPV_check</a></code></li>
<li><code><a title="bank_regulation_project.utils.determine_line_color" href="#bank_regulation_project.utils.determine_line_color">determine_line_color</a></code></li>
<li><code><a title="bank_regulation_project.utils.generate_GBM" href="#bank_regulation_project.utils.generate_GBM">generate_GBM</a></code></li>
<li><code><a title="bank_regulation_project.utils.get_a_exponent" href="#bank_regulation_project.utils.get_a_exponent">get_a_exponent</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>